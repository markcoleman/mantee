<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mantee the Manta Ray (8-bit Style)</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      background: #003B73;
      overflow: hidden;
      font-family: Arial, sans-serif; /* Will be overridden in canvas with 8-bit font */
    }
    canvas {
      display: block;
      margin: 20px auto 0;
      background: linear-gradient(#003B73, #001F3F);
      border: 2px solid #fff;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="800" height="400"></canvas>

  <script>
    // =========================
    // CANVAS & CONTEXT
    // =========================
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const W = canvas.width;
    const H = canvas.height;

    // =========================
    // IMAGES
    // =========================
    const titleImage = new Image();
    titleImage.src = 'title.png';       // Title-screen image

    const backgroundImg = new Image();
    backgroundImg.src = 'background.png'; // Scrolling background

    const manteeImg = new Image();
    manteeImg.src = 'mantee.png';       // Mantee sprite

    const heartImg = new Image();
    heartImg.src = 'heart.png';         // Heart collectible

    const coralImg = new Image();
    coralImg.src = 'coral.png';         // Coral obstacle (stretched)

    const caveImg = new Image();
    caveImg.src = 'cave.png';           // Cave/tunnel tile (repeated)

    // =========================
    // GAME STATE VARIABLES
    // =========================
    let gameState = 'title';    // 'title', 'playing', 'win', 'gameover'
    let roundNumber = 1;
    let cameraX = 0;            // How far we've scrolled

    // Score & High Score
    let score = 0;
    let highScore = 0;

    // Mantee data
    const mantee = {
      x: 150,
      y: H / 2,
      width: 80,
      height: 48,
      speed: 4
    };

    // World data
    let obstacles = [];     // Array of obstacle objects
    let hearts = [];        // Array of hearts
    let worldWidth = 4000;  // Full width of the level
    let goalX = 3800;       // Where the goal line is
    let scrollSpeed = 2;    // Scroll speed

    // Keyboard input
    let upPressed = false;
    let downPressed = false;

    // =========================
    // EVENT LISTENERS
    // =========================
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowUp') upPressed = true;
      if (e.key === 'ArrowDown') downPressed = true;

      if (e.code === 'Space') {
        if (gameState === 'title' || gameState === 'gameover') {
          startNewRound();
        }
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowUp') upPressed = false;
      if (e.key === 'ArrowDown') downPressed = false;
    });

    // =========================
    // MAIN LOOP
    // =========================
    function gameLoop() {
      ctx.clearRect(0, 0, W, H);

      switch (gameState) {
        case 'title':
          drawTitleScreen();
          break;
        case 'playing':
          updateGame();
          drawGame();
          break;
        case 'win':
          drawGame();
          drawWinScreen();
          break;
        case 'gameover':
          drawGame();
          drawGameOverScreen();
          break;
      }

      requestAnimationFrame(gameLoop);
    }

    // =========================
    // GAME UPDATE
    // =========================
    function updateGame() {
      // Move camera to the right
      cameraX += scrollSpeed;

      // Mantee movement
      if (upPressed) mantee.y -= mantee.speed;
      if (downPressed) mantee.y += mantee.speed;

      // Boundaries
      if (mantee.y < 0) mantee.y = 0;
      if (mantee.y + mantee.height > H) {
        mantee.y = H - mantee.height;
      }

      // Check collisions with obstacles
      for (let obs of obstacles) {
        for (let r of obs.rects) {
          const rectLeft = r.x - cameraX;
          const rectRight = rectLeft + r.width;
          const rectTop = r.y;
          const rectBottom = r.y + r.height;

          const manteeLeft = mantee.x;
          const manteeRight = mantee.x + mantee.width;
          const manteeTop = mantee.y;
          const manteeBottom = mantee.y + mantee.height;

          if (
            manteeRight > rectLeft &&
            manteeLeft < rectRight &&
            manteeBottom > rectTop &&
            manteeTop < rectBottom
          ) {
            // Collision => GameOver
            gameOver();
            return;
          }
        }
      }

      // Check collisions with hearts
      for (let i = 0; i < hearts.length; i++) {
        const heart = hearts[i];
        const heartLeft = heart.x - cameraX;
        const heartRight = heartLeft + heart.width;
        const heartTop = heart.y;
        const heartBottom = heart.y + heart.height;

        const manteeLeft = mantee.x;
        const manteeRight = mantee.x + mantee.width;
        const manteeTop = mantee.y;
        const manteeBottom = mantee.y + mantee.height;

        if (
          manteeRight > heartLeft &&
          manteeLeft < heartRight &&
          manteeBottom > heartTop &&
          manteeTop < heartBottom
        ) {
          // Collect heart
          hearts.splice(i, 1);
          i--;

          score++;
          if (score > highScore) {
            highScore = score;
          }
        }
      }

      // Check if reached the goal
      const manteeWorldX = cameraX + mantee.x + mantee.width / 2;
      if (manteeWorldX >= goalX) {
        gameState = 'win';
        setTimeout(() => {
          roundNumber++;
          startNewRound();
        }, 2000);
      }
    }

    // =========================
    // DRAW FUNCTIONS
    // =========================
    function drawGame() {
      drawScrollingBackground();
      drawObstacles();
      drawHearts();
      drawGoal();
      drawMantee(mantee.x, mantee.y, mantee.width, mantee.height);
      drawProgressBar();
      drawScoreText(); // 8-bit style text on top-right
    }

    function drawTitleScreen() {
      // Draw title image
      ctx.drawImage(titleImage, 0, 0, W, H);

      // Dark overlay
      ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
      ctx.fillRect(0, 0, W, H);

      // 8-bit style text
      ctx.fillStyle = '#ffffff';
      ctx.font = '28px "Courier New", monospace'; 
      ctx.textAlign = 'center';
      ctx.fillText('MANTEE THE MANTA RAY', W / 2, H / 2 - 20);

      ctx.font = '20px "Courier New", monospace';
      ctx.fillText('Press SPACE to Start', W / 2, H / 2 + 20);
    }

    function drawScrollingBackground() {
      if (backgroundImg.complete) {
        // Suppose backgroundImg is at least as wide as worldWidth
        const maxCameraX = Math.max(0, backgroundImg.width - W);
        const sourceX = Math.min(cameraX, maxCameraX);

        ctx.drawImage(
          backgroundImg,
          sourceX, 0,   // source
          W, H,         // slice width & height
          0, 0,         // destination coords
          W, H          // destination size
        );
      } else {
        // fallback
        ctx.fillStyle = '#003B73';
        ctx.fillRect(0, 0, W, H);
      }
    }

    function drawObstacles() {
      // If obstacle is "coral", stretch coralImg; if "tunnel", tile caveImg
      for (let obs of obstacles) {
        for (let r of obs.rects) {
          const screenX = r.x - cameraX;
          // Check the "type" property we store to see if it's coral or cave
          if (obs.type === 'coral') {
            // Stretch coral
            ctx.drawImage(
              coralImg,
              0, 0, coralImg.width, coralImg.height,
              screenX, r.y, r.width, r.height
            );
          } else {
            // tile with cave.png
            drawTiledCave(caveImg, screenX, r.y, r.width, r.height);
          }
        }
      }
    }

    // Helper to tile the cave image within a rectangle
    function drawTiledCave(image, destX, destY, destW, destH) {
      // We'll repeat drawing the cave in small slices
      // For performance, you might prefer using pattern fill,
      // but let's do a loop for clarity.
      const tileW = image.width;
      const tileH = image.height;
      if (!tileW || !tileH) return; // if image not loaded, skip

      // We iterate over the rectangle in multiples of tile size
      for (let y = 0; y < destH; y += tileH) {
        for (let x = 0; x < destW; x += tileW) {
          // We might need partial tiles at edges
          const drawW = Math.min(tileW, destW - x);
          const drawH = Math.min(tileH, destH - y);

          ctx.drawImage(
            image,
            0, 0, drawW, drawH,        // source
            destX + x, destY + y,      // destination
            drawW, drawH
          );
        }
      }
    }

    function drawHearts() {
      for (let heart of hearts) {
        const screenX = heart.x - cameraX;
        ctx.drawImage(heartImg, screenX, heart.y, heart.width, heart.height);
      }
    }

    function drawGoal() {
      const lineX = goalX - cameraX;
      if (lineX > 0 && lineX < W) {
        ctx.save();
        ctx.strokeStyle = 'yellow';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(lineX, 0);
        ctx.lineTo(lineX, H);
        ctx.stroke();

        ctx.fillStyle = '#fff';
        ctx.font = '16px "Courier New", monospace';
        ctx.textAlign = 'center';
        ctx.fillText('GOAL', lineX + 10, H / 2);
        ctx.restore();
      }
    }

    function drawMantee(x, y, width, height) {
      ctx.drawImage(manteeImg, x, y, width, height);
    }

    function drawProgressBar() {
      const manteeWorldX = cameraX + mantee.x + mantee.width / 2;
      let progress = manteeWorldX / goalX;
      if (progress > 1) progress = 1;

      const barWidthMax = 200;
      const barHeight = 12;
      const barX = (W - barWidthMax) / 2;
      const barY = 5;

      // background
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.fillRect(barX, barY, barWidthMax, barHeight);

      // fill
      ctx.fillStyle = '#00FF00';
      ctx.fillRect(barX, barY, barWidthMax * progress, barHeight);

      // border
      ctx.strokeStyle = '#000';
      ctx.strokeRect(barX, barY, barWidthMax, barHeight);
    }

    // Draw 8-bit style Score & Round in top-right corner
    function drawScoreText() {
      ctx.save();
      ctx.fillStyle = '#fff';
      ctx.font = '16px "Courier New", monospace'; // 8-bit style
      ctx.textAlign = 'right';

      // Letâ€™s place it near top-right
      const textX = W - 10;
      const textY = 20;
      const textLines = [
        `ROUND: ${roundNumber}`,
        `SCORE: ${score}`,
        `HIGH:  ${highScore}`
      ];

      textLines.forEach((line, i) => {
        ctx.fillText(line, textX, textY + i * 20);
      });

      ctx.restore();
    }

    function drawWinScreen() {
      ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = '#ffffff';
      ctx.font = '28px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('YOU WIN!', W / 2, H / 2);
    }

    function drawGameOverScreen() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.fillRect(0, 0, W, H);

      ctx.fillStyle = '#ff3333';
      ctx.font = '28px "Courier New", monospace';
      ctx.textAlign = 'center';
      ctx.fillText('CRASHED INTO CORAL!', W / 2, H / 2 - 10);

      ctx.fillStyle = '#ffffff';
      ctx.font = '20px "Courier New", monospace';
      ctx.fillText('Press SPACE to try again...', W / 2, H / 2 + 30);
    }

    // =========================
    // WORLD GENERATION
    // =========================
    function generateWorld() {
      const obstacleCount = 5 + Math.floor(Math.random() * 4);
      const newObstacles = [];

      for (let i = 0; i < obstacleCount; i++) {
        const obstacleX = 800 + i * 500 + Math.random() * 200;
        const obstacleType = Math.random() < 0.5 ? 'coral' : 'tunnel';

        if (obstacleType === 'coral') {
          const obsHeight = 50 + Math.random() * 150; 
          const rects = [{
            x: obstacleX,
            y: H - obsHeight,
            width: 80,
            height: obsHeight
          }];
          newObstacles.push({ type: 'coral', rects });
        } else {
          // Tunnel => top + bottom blocks with a gap, both are "cave"
          const gapSize = 100 + Math.random() * 80;
          const topHeight = 50 + Math.random() * 120;
          const bottomHeight = H - (topHeight + gapSize);
          const rects = [
            { x: obstacleX, y: 0, width: 80, height: topHeight },
            { x: obstacleX, y: H - bottomHeight, width: 80, height: bottomHeight }
          ];
          newObstacles.push({ type: 'cave', rects });
        }
      }

      goalX = worldWidth - 200;
      return newObstacles;
    }

    function generateHearts() {
      const heartCount = 5 + Math.floor(Math.random() * 4);
      const newHearts = [];

      for (let i = 0; i < heartCount; i++) {
        const hx = 300 + Math.random() * (worldWidth - 600);
        const hy = Math.random() * (H - 32);
        newHearts.push({
          x: hx,
          y: hy,
          width: 32,
          height: 32
        });
      }
      return newHearts;
    }

    // =========================
    // ROUND / GAME INIT
    // =========================
    function startNewRound() {
      cameraX = 0;
      mantee.y = H / 2;

      obstacles = generateWorld();
      hearts = generateHearts();

      if (gameState === 'gameover') {
        score = 0;
      }

      gameState = 'playing';
    }

    function gameOver() {
      if (score > highScore) {
        highScore = score;
      }
      gameState = 'gameover';
    }

    // Start the loop
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>